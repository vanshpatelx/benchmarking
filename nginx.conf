# worker_processes auto;

# events {
#     worker_connections 65535;
#     use epoll;                    # Efficient I/O for Linux
#     multi_accept on;              # Accept all incoming connections at once
# }

# http {
#     sendfile on;
#     tcp_nopush on;
#     tcp_nodelay on;

#     keepalive_timeout 30;
#     keepalive_requests 100000;
#     client_max_body_size 10M;

#     server {
#         listen 80;

#         location / {
#             proxy_pass http://go-api:8080;
#             proxy_http_version 1.1;
#             proxy_set_header Connection "";
#             proxy_set_header Host $host;
#             proxy_set_header X-Real-IP $remote_addr;
#             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

#             proxy_read_timeout 60s;
#             proxy_connect_timeout 5s;
#             proxy_send_timeout 60s;
#         }
#     }
# }

# Set to number of CPU cores or slightly higher
worker_processes 4;  # Adjust based on your system's CPU cores

# Increase worker file descriptor limit
worker_rlimit_nofile 65535;

events {
    worker_connections 16384;    # Reduced but more realistic
    use epoll;
    multi_accept on;
    accept_mutex off;            # Disable accept mutex for better performance
}

http {
    # Basic optimizations
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    
    # Connection management
    keepalive_timeout 65;
    keepalive_requests 1000;
    
    # Buffer sizes
    client_body_buffer_size 128k;
    client_max_body_size 10m;
    client_header_buffer_size 1k;
    large_client_header_buffers 4 4k;
    output_buffers 1 32k;
    postpone_output 1460;
    
    # Upstream configuration with connection pooling
    upstream go_backend {
        server go-api:8080 max_fails=3 fail_timeout=30s;
        keepalive 300;           # Keep 300 connections alive
        keepalive_requests 1000;  # Reuse connections
        keepalive_timeout 60s;
    }
    
    # Rate limiting (optional but recommended)
    limit_req_zone $binary_remote_addr zone=api:10m rate=1000r/s;
    limit_conn_zone $binary_remote_addr zone=conn_limit_per_ip:10m;
    
    server {
        listen 80 reuseport;     # Enable SO_REUSEPORT for better load distribution
        
        # Rate limiting
        limit_req zone=api burst=2000 nodelay;
        limit_conn conn_limit_per_ip 50;
        
        # Disable access logging for performance (optional)
        access_log off;
        
        location / {
            # Use upstream instead of direct proxy_pass
            proxy_pass http://go_backend;
            
            # HTTP version and connection reuse
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            
            # Headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeouts - more aggressive
            proxy_connect_timeout 5s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;
            
            # Buffering
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;
            proxy_busy_buffers_size 8k;
            
            # Don't buffer small responses
            proxy_max_temp_file_size 0;
        }
        
        # Health check endpoint (bypass proxy for faster response)
        location = /nginx-health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
}